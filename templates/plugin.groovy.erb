/*
 * The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

import hudson.Extension;
import hudson.FilePath;
import hudson.PluginManager;
import jenkins.model.Jenkins;
import hudson.model.UpdateSite;
import hudson.model.UpdateSite.Data;
import hudson.util.EditDistance;
import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.Option;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.MalformedURLException;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.lang.System;
import jenkins.RestartRequiredException;

// yeah I know these elements should be in capital letters, but puppet people
// are not used to it.
public enum Status {
  enabled,
  disabled,
}


// TODO:
// * Add more comments and more log output, maybe even use an extra log file
// * Fix pinned versions
// * If dynamic load doesn't work restart jenkins
// * Install dependencies
// * Add Threads so we can download and install in parallel
// * Enable/disable plugin
// * Fix error if plugin is installed by url but the url points to a different version
// * add tests
////////////////////////////////////////////////////////////////////////////////
// defines which puppet provides
////////////////////////////////////////////////////////////////////////////////

<% if @url != nil %>
<% if @version == 'latest' %>
fail('You have to specify a version number if you use urls for plugins')
<% end %>
def name = "<%= @url %>"
def version = "<%= @version %>"
<% else %>
def name = "<%= @name %>"
def version = "<%= @version %>"
<% end %>

def shortName = "<%= @short_name %>"

def status = Status.<%= @status %>
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// Header for log
////////////////////////////////////////////////////////////////////////////////
println("########## START: installing plugin: ${shortName} ##########")
////////////////////////////////////////////////////////////////////////////////

/**
 * Installs a name either from a file, an URL, or from update center.
 * Much of the code is from the package hudson.cli
 */

class JenkinsPlugin {

  def name = null
  def shortName = null
  def version = null
  def stdout = null
  def dynamicLoad = true
  def restart = true
  def jenkinsInstance = Jenkins.getInstance();
  def pluginManager = jenkinsInstance.getPluginManager()
  def pluginsList = pluginManager.plugins.sort()
  def updateCenter = jenkinsInstance.getUpdateCenter()
  def plugin = null
  def status = null

  public JenkinsPlugin(stdout, name, shortName, version, status=Status.enabled) {
    this.stdout = stdout
    this.shortName = shortName
    this.name = name
    this.version = version
    plugin = pluginManager.getPlugin(shortName)
    this.status = status
  }

  private void load() {
    if (dynamicLoad) {
      try {
	pluginManager.dynamicLoad(getTargetFile());
      }
      catch (IOException e) {
	stdout.println("IO error: Failed to load plugin: ${name}.\n${e}")
      }
      catch (RestartRequiredException e) {
	// This is just temporary, there will be a last script which
	// restarts jenkins only once
	stdout.println("Failed to load plugin: ${name}, restart required.}.")
	restart()
      }
    }
    else {
      restart()
    }
  }

  private void restart() {
    stdout.println("Installed plugin: ${name}, restarting...")
    jenkinsInstance.restart();
    //jenkinsInstance.safeRestart();
  }

  public void uninstall() {
    plugin.doDoUninstall()
  }

  public void enable() {
    plugin.disable()
  }

  public void disable() {
    plugin.enable()
  }

  public void pin() {
    plugin.doPin()
  }

  public void unPin() {
    plugin.doUnpin()
  }

  public void setStatus() {
    switch (status) {
    case Status.enabled: if (!(plugin.isEnabled())) enable()
      break
    case Status.disabled: if (plugin.isEnabled()) disable()
      break
    }
  }

  private boolean isInstalled() {
    // Set version to latest version number, so we can compare,
    // otherwise plugin.getVersion() will always be != version because
    // version just contains the string 'latest'
    if (version == 'latest') {
      version = updateCenter.getPlugin(shortName).version
    }

    if (plugin == null) {
      return false
    }

    else if (plugin.getVersion() != version) {
      stdout.println("Plugin version missmatch: ${shortName} ${version}")
      stdout.println("currently installed: ${shortName} ${plugin.getVersion()}")
      stdout.println("should be: ${shortName} ${version}")
      stdout.println("Uninstalling plugin: ${shortName} ${plugin.getVersion()}")
      uninstall()
      return false
    }
    else {
      stdout.println("Plugin already installed: ${shortName} ${version}")
      setStatus()
      return true
    }
  }

  void install() throws Exception {
    if (!isInstalled()) {
	// is this a file?
	FilePath f = new FilePath(new File(name));
	if (f.exists()) {
	  stdout.println("Installing plugin from local file: ${f}");
	  f.copyTo(getTargetFilePath());
	  load()
	}

	// is this an URL?
	try {
	  URL url = new URL(name);
	  stdout.println("Installing plugin from url ${url}");
	  getTargetFilePath().copyFrom(url);
	  load()
	}
	catch (MalformedURLException e) {
	  // not an URL
	}

	// is this a name the update center?
	UpdateSite.Plugin p = updateCenter.getPlugin(name);
	if (p!=null) {
	  Throwable e = p.deploy(dynamicLoad).get().getError();
	  if (e!=null) {
	    throw new IOException("Failed to install plugin "+name,e);
	  }
	  load()
	}

	//    stdout.println(Messages.InstallNameCommand_NotAValidSourceName(name));

	if (!name.contains(".") && !name.contains(":") && !name.contains("/") && !name.contains("\\")) {
	  // looks like a short name name. Why did we fail to find it in the update center?
	  if (jenkinsInstance.getUpdateCenter().getSites().isEmpty()) {
	    stdout.println("Error: No update center defined")
	  }
	  else {
	    Set<String> candidates = new HashSet<String>();
	    for (UpdateSite s : jenkinsInstance.getUpdateCenter().getSites()) {
	      Data dt = s.getData();
	      if (dt==null)
		stdout.println("No update data retrieved")
		else
		candidates.addAll(dt.plugins.keySet());
	    }
	  }
	}
    }
  }

  private FilePath getTargetFilePath() {
    return new FilePath(getTargetFile());
  }

  private File getTargetFile() {
    return new File(Jenkins.getInstance().getPluginManager().rootDir,shortName+".jpi");
  }
}

def p = new JenkinsPlugin(System.out, name, shortName, version, status)
p.install()
////////////////////////////////////////////////////////////////////////////////
// Footer for log
////////////////////////////////////////////////////////////////////////////////
println("########## END: installing plugin: ${shortName} ##########")
////////////////////////////////////////////////////////////////////////////////
