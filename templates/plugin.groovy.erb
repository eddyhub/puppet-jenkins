/*
 * The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

import hudson.Extension;
import hudson.FilePath;
import hudson.PluginManager;
import jenkins.model.Jenkins;
import hudson.model.UpdateSite;
import hudson.model.UpdateSite.Data;
import hudson.util.EditDistance;
import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.Option;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.MalformedURLException;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.lang.System;
import groovy.json.JsonSlurper;
import groovy.io.FileType;
import jenkins.RestartRequiredException;


// TODO:
// * Add more comments and more log output, maybe even use an extra log file
// * Fix pinned versions
// * If dynamic load doesn't work restart jenkins
// * Install dependencies
// * Add Threads so we can download and install in parallel
// * Enable/disable plugin
// * Fix error if plugin is installed by url but the url points to a different version
// * add tests

////////////////////////////////////////////////////////////////////////////////
// Header for log
////////////////////////////////////////////////////////////////////////////////
println("########## BEGIN: installing plugins ##########")
////////////////////////////////////////////////////////////////////////////////

/**
 * Installs a name either from a file, an URL, or from update center.
 * Much of the code is from the package hudson.cli
 */

class JenkinsPluginManager {

  def stdout = null
  def needRestart = false
  def jenkinsInstance = Jenkins.getInstance();
  def pluginManager = jenkinsInstance.getPluginManager()
  def pluginsList = pluginManager.plugins.sort()
  def updateCenter = jenkinsInstance.getUpdateCenter()
  def listOfRequestedPlugins = []
  def listOfPluginsToInstall = []
  def listOfPluginsToDisable = []
  def listOfPluginsToRemove = pluginsList.collect { pluginWrapper -> pluginWrapper.getShortName() }
  def fileNamePattern = ~/plugin.*\.json/

  public JenkinsPluginManager(stdout, jsonDir) {
    this.stdout = stdout
    updateAllSites()
    stdout.println("Cheking ${jsonDir} for plugin.*\\.json.")
    new File(jsonDir).eachFileMatch(FileType.FILES, fileNamePattern) {file ->
      stdout.println("Found plugin description: ${file}")
      listOfRequestedPlugins << new JsonSlurper().parse(new BufferedReader(new FileReader(file)))
    }
    listOfRequestedPlugins.each { jsonDoc ->
      def version = updateCenter.getPlugin(jsonDoc.shortName).version
      def url = updateCenter.getPlugin(jsonDoc.shortName).url
      jsonDoc.urlAdded = false
      if(jsonDoc.version == 'latest') {
	jsonDoc.version = version
      }
      if(jsonDoc.url == '') {
	jsonDoc.url = url
	jsonDoc.urlAdded = true
      }
    }
    listOfRequestedPlugins.each { jsonDoc ->
      if(pluginManager.getPlugin(jsonDoc.shortName) == null ||
	 pluginManager.getPlugin(jsonDoc.shortName).getVersion() != jsonDoc.version) {
	stdout.println("Plugin ${jsonDoc.shotName} not installed or version missmatch.")
	listOfPluginsToInstall << jsonDoc
      }
      listOfPluginsToRemove.remove(jsonDoc.shortName)
    }
    listOfPluginsToInstall.each { jsonDoc ->
      install(jsonDoc)
    }
    if(needRestart) { restart() }
  }

  public void updateAllSites() {
    System.out.println("Updating update center metadata file")
    updateCenter.updateAllSites()
    System.out.println("Updating update center metadata file [done]")
  }

  private void restart() {
    jenkinsInstance.restart();
    // sleep untill restart
    while (true) {
      sleep(1000)
      stdout.println("Waiting for restart...")
    }
  }

  void install(jsonPluginDescription) throws Exception {
    // is this a file?
    def shortName = jsonPluginDescription.shortName
    def url = jsonPluginDescription.url
    def urlAdded = jsonPluginDescription.urlAdded
    stdout.println("Installing plugin: ${shortName}...")
    //is it a file
    FilePath f = new FilePath(new File(url));
    if (f.exists()) {
      stdout.println("Installing plugin from local file: ${f}");
      f.copyTo(getTargetFilePath(shortName));
    }

    // is it an web URL?
    if(!urlAdded) {
      try {
	URL tmpUrl = new URL(url);
	stdout.println("Installing plugin from url ${tmpUrl}");
	getTargetFilePath().copyFrom(tmpUrl);
      }
      catch (MalformedURLException e) {
	// not an URL
      }
    }
    else {
      // is this a name the update center?
      UpdateSite.Plugin p = updateCenter.getPlugin(shortName);
      stdout.println("Installing plugin via UpdateCenter");
      if (p!=null) {
	Throwable e = p.deploy(true).get().getError();
	if (e!=null) {
	  throw new IOException("Failed to install plugin "+shortName,e);
	}
      }
    }
    try {
      pluginManager.dynamicLoad(getTargetFile(shortName))
    }
    catch (IOException e) {
      stdout.println("Couldn't load plugin: Could not read file ${getTargetFile(shortName)}")
    }
    catch (RestartRequiredException e) {
      stdout.println("Couldn't load plugin while running: Restart required -> Restarting after all plugins are installed")
      needRestart = true
    }
  }

  private FilePath getTargetFilePath(shortName) {
    return new FilePath(getTargetFile(shortName));
  }

  private File getTargetFile(shortName) {
    return new File(pluginManager.rootDir,shortName+".jpi");
  }
}

new JenkinsPluginManager(System.out, "<%= @json_dir %>")
////////////////////////////////////////////////////////////////////////////////
// Footer for log
////////////////////////////////////////////////////////////////////////////////
println("########## END: installing plugins ##########")
////////////////////////////////////////////////////////////////////////////////
